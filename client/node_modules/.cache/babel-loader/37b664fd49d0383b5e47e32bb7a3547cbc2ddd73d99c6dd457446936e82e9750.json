{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport { useMutation, useQuery } from '@apollo/client';\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from '../graphql/queries';\nconst useTaskFlow = () => {\n  _s();\n  const {\n    loading,\n    error,\n    data\n  } = useQuery(GET_COLUMNS);\n  const [columns, setColumns] = useState([]);\n  const [addCardMutation] = useMutation(ADD_CARD);\n  const [moveCardMutation] = useMutation(MOVE_CARD);\n  const [deleteCardMutation] = useMutation(DELETE_CARD);\n  const [changeUserMutation] = useMutation(CHANGE_USER);\n  const [draggedCard, setDraggedCard] = useState(null);\n  const [users, setUsers] = useState([]);\n\n  // Inside useTaskFlow hook\n\n  const onAddCard = async (columnId, text) => {\n    if (!text.trim()) return; // Prevent adding empty cards\n\n    await addCardMutation({\n      variables: {\n        columnId,\n        text\n      },\n      update: (cache, {\n        data: {\n          addCard\n        }\n      }) => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n        const newColumns = existingData.getColumns.map(column => {\n          if (column.id === columnId) {\n            // Assuming your backend returns the updated column after adding a card\n            return {\n              ...column,\n              cards: [...column.cards, addCard]\n            };\n          }\n          return column;\n        });\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n    // Optionally clear the input field for this column in the state here if not done elsewhere\n  };\n  const onDeleteCard = async cardId => {\n    await deleteCardMutation({\n      variables: {\n        cardId\n      },\n      update: cache => {\n        // Read the current state of the columns from the cache\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n\n        // Clone the existing columns to avoid direct mutation\n        const newColumns = existingData.getColumns.map(column => {\n          // Filter out the deleted card from each column's cards\n          const filteredCards = column.cards.filter(card => card.id !== cardId);\n          return {\n            ...column,\n            cards: filteredCards\n          };\n        });\n\n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n  };\n  const onDragEnd = async result => {\n    const {\n      draggableId,\n      source,\n      destination\n    } = result;\n\n    // Check if there's a destination and the card is moved to a new place\n    if (!destination || destination.droppableId === source.droppableId && destination.index === source.index) {\n      return; // Do nothing if there's no destination or the card was dropped back to its original place\n    }\n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n\n        // Cloning the existing columns to avoid direct mutation\n        const newColumns = existingData.getColumns.map(column => ({\n          ...column,\n          cards: [...column.cards]\n        }));\n\n        // Find and remove the card from its original column\n        const sourceColumnIndex = newColumns.findIndex(column => column.id === source.droppableId);\n        const cardIndex = newColumns[sourceColumnIndex].cards.findIndex(card => card.id === draggableId);\n        const [movedCard] = newColumns[sourceColumnIndex].cards.splice(cardIndex, 1);\n\n        // Add the card to its new column\n        const destinationColumnIndex = newColumns.findIndex(column => column.id === destination.droppableId);\n        newColumns[destinationColumnIndex].cards.splice(destination.index, 0, movedCard);\n\n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n  };\n  const onUserSelect = async (cardId, user) => {\n    await changeUserMutation({\n      variables: {\n        cardId,\n        assignedUser: user.id\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n\n        // Create a new array with updated cards\n        const newColumns = existingData.getColumns.map(column => {\n          const newCards = column.cards.map(card => {\n            if (card.id === cardId) {\n              // Update the card with the new assigned user\n              return {\n                ...card,\n                assignedUser: user.id\n              };\n            }\n            return card;\n          });\n          return {\n            ...column,\n            cards: newCards\n          };\n        });\n\n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    }).catch(error => console.error('Failed to assign user to card:', error));\n  };\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns || []);\n      setUsers(data.getUsers || []);\n    }\n  }, [loading, data]);\n  return {\n    loading,\n    error,\n    columns,\n    draggedCard,\n    users,\n    setDraggedCard,\n    onAddCard,\n    onDragEnd,\n    onDeleteCard,\n    onUserSelect\n  };\n};\n_s(useTaskFlow, \"d/h7A5RB5l8QSMQ34A9Jk62o8c4=\", false, function () {\n  return [useQuery, useMutation, useMutation, useMutation, useMutation];\n});\nexport default useTaskFlow;","map":{"version":3,"names":["useEffect","useState","useMutation","useQuery","GET_COLUMNS","ADD_CARD","MOVE_CARD","DELETE_CARD","CHANGE_USER","useTaskFlow","_s","loading","error","data","columns","setColumns","addCardMutation","moveCardMutation","deleteCardMutation","changeUserMutation","draggedCard","setDraggedCard","users","setUsers","onAddCard","columnId","text","trim","variables","update","cache","addCard","existingData","readQuery","query","newColumns","getColumns","map","column","id","cards","writeQuery","onDeleteCard","cardId","filteredCards","filter","card","onDragEnd","result","draggableId","source","destination","droppableId","index","newColumnId","optimisticResponse","moveCard","__typename","sourceColumnIndex","findIndex","cardIndex","movedCard","splice","destinationColumnIndex","onUserSelect","user","assignedUser","newCards","catch","console","getUsers"],"sources":["/Users/dazzlinger/Desktop/start_here/TaskFlow/client/src/main/hook.ts"],"sourcesContent":["import { useEffect, useState } from 'react'\nimport { type  DropResult } from 'react-beautiful-dnd'\nimport { useMutation, useQuery } from '@apollo/client'\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from '../graphql/queries'\nimport { type User, type BoardData, type Column } from './types'\n\nexport interface UseTaskFlowReturn {\n  loading: boolean\n  error: Error | undefined\n  columns: Column[] | undefined\n  draggedCard: string | null\n  users: User[]\n  setDraggedCard: (cardId: string | null) => void\n  onAddCard: (columnId: string, text: string) => Promise<void>\n  onDragEnd: (result: any) =>  Promise<void>\n  onDeleteCard: (cardId: string) => Promise<void>\n  onUserSelect: (cardId: string, user: User) => Promise<void>\n}\n\nconst useTaskFlow = (): UseTaskFlowReturn => {\n  const { loading, error, data } = useQuery<BoardData>(GET_COLUMNS)\n  const [columns, setColumns] = useState<Column[]>([])\n  const [addCardMutation] = useMutation(ADD_CARD)\n  const [moveCardMutation] = useMutation(MOVE_CARD)\n  const [deleteCardMutation] = useMutation(DELETE_CARD)\n  const [changeUserMutation] = useMutation(CHANGE_USER)\n  const [draggedCard, setDraggedCard] = useState<string | null>(null)\n  const [users, setUsers] = useState<User[]>([])\n\n  // Inside useTaskFlow hook\n\n  const onAddCard = async (columnId: string, text: string) => {\n    if (!text.trim()) return // Prevent adding empty cards\n\n    await addCardMutation({\n      variables: { columnId, text },\n      update: (cache, { data: { addCard } }) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n\n        const newColumns = existingData.getColumns.map(column => {\n          if (column.id === columnId) {\n          // Assuming your backend returns the updated column after adding a card\n            return { ...column, cards: [...column.cards, addCard] }\n          }\n          return column\n        })\n\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n  // Optionally clear the input field for this column in the state here if not done elsewhere\n  }\n\n  const onDeleteCard = async (cardId: string) => {\n    await deleteCardMutation({\n      variables: { cardId },\n      update: (cache) => {\n        // Read the current state of the columns from the cache\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        // Clone the existing columns to avoid direct mutation\n        const newColumns = existingData.getColumns.map(column => {\n          // Filter out the deleted card from each column's cards\n          const filteredCards = column.cards.filter(card => card.id !== cardId)\n          return { ...column, cards: filteredCards }\n        })\n  \n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n  }\n\n  const onDragEnd = async (result: DropResult) => {\n    const { draggableId, source, destination } = result\n  \n    // Check if there's a destination and the card is moved to a new place\n    if (!destination || (destination.droppableId === source.droppableId && destination.index === source.index)) {\n      return // Do nothing if there's no destination or the card was dropped back to its original place\n    }\n  \n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: (cache) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        // Cloning the existing columns to avoid direct mutation\n        const newColumns = existingData.getColumns.map(column => ({ ...column, cards: [...column.cards] }))\n  \n        // Find and remove the card from its original column\n        const sourceColumnIndex = newColumns.findIndex(column => column.id === source.droppableId)\n        const cardIndex = newColumns[sourceColumnIndex].cards.findIndex(card => card.id === draggableId)\n        const [movedCard] = newColumns[sourceColumnIndex].cards.splice(cardIndex, 1)\n  \n        // Add the card to its new column\n        const destinationColumnIndex = newColumns.findIndex(column => column.id === destination.droppableId)\n        newColumns[destinationColumnIndex].cards.splice(destination.index, 0, movedCard)\n  \n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n  }\n\n  const onUserSelect = async (cardId: string, user: User) => {\n    await changeUserMutation({\n      variables: { cardId, assignedUser: user.id },\n      update: (cache) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n\n        // Create a new array with updated cards\n        const newColumns = existingData.getColumns.map(column => {\n          const newCards = column.cards.map(card => {\n            if (card.id === cardId) {\n              // Update the card with the new assigned user\n              return { ...card, assignedUser: user.id }\n            }\n            return card\n          })\n          return { ...column, cards: newCards }\n        })\n\n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    }).catch(error => console.error('Failed to assign user to card:', error))\n  }\n\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns || [])\n      setUsers(data.getUsers || [])\n    }\n  }, [loading, data])\n\n  return {\n    loading,\n    error,\n    columns,\n    draggedCard,\n    users,\n    setDraggedCard,\n    onAddCard,\n    onDragEnd,\n    onDeleteCard,\n    onUserSelect\n  }\n}\n\nexport default useTaskFlow\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}