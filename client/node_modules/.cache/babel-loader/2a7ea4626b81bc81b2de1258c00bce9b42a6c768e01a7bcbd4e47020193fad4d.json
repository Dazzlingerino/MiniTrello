{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport { useMutation, useQuery } from '@apollo/client';\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from 'graphql/queries';\nconst useBoard = () => {\n  _s();\n  const {\n    loading,\n    error,\n    data\n  } = useQuery(GET_COLUMNS);\n  const [columns, setColumns] = useState([]);\n  const [addCardMutation] = useMutation(ADD_CARD);\n  const [moveCardMutation] = useMutation(MOVE_CARD);\n  const [deleteCardMutation] = useMutation(DELETE_CARD);\n  const [changeUserMutation] = useMutation(CHANGE_USER);\n  const [draggedCard, setDraggedCard] = useState(null);\n  const [users, setUsers] = useState([]);\n  const sortCardsInColumn = (columnId, sortOrder) => {\n    const sortedColumns = columns.map(column => {\n      if (column.id === columnId) {\n        const sortedCards = [...column.cards];\n        if (sortOrder === 'creationDate') {\n          sortedCards.sort((a, b) => new Date(a.creationDate).getTime() - new Date(b.creationDate).getTime());\n        } else if (sortOrder === 'customOrder') {\n          sortedCards.sort((a, b) => a.customOrder - b.customOrder);\n        }\n        return {\n          ...column,\n          cards: sortedCards\n        };\n      }\n      return column;\n    });\n    setColumns(sortedColumns);\n  };\n  const onAddCard = async (columnId, text) => {\n    if (!text.trim()) return;\n    const optimisticCardId = 'temp-id';\n    const customOrder = Math.floor(Math.random() * 101);\n    await addCardMutation({\n      variables: {\n        columnId,\n        text\n      },\n      optimisticResponse: {\n        __typename: 'Mutation',\n        addCard: {\n          __typename: 'Card',\n          id: optimisticCardId,\n          text,\n          assignedUser: null,\n          creationDate: new Date().toISOString(),\n          customOrder\n        }\n      },\n      update(cache) {\n        cache.modify({\n          fields: {\n            getColumns(existingColumnRefs, {\n              readField\n            }) {\n              const newCardRef = cache.writeFragment({\n                data: addCard,\n                fragment: gql`\n                  fragment NewCard on Card {\n                    id\n                    text\n                    assignedUser\n                    creationDate\n                    customOrder\n                  }\n                `\n              });\n              const columnIdToUpdate = columnId;\n              const column = existingColumnRefs.find(columnRef => readField('id', columnRef) === columnIdToUpdate);\n              if (column) {\n                cache.modify({\n                  id: cache.identify(column),\n                  fields: {\n                    cards(existingCardRefs = []) {\n                      return [...existingCardRefs, newCardRef];\n                    }\n                  }\n                });\n              }\n              return existingColumnRefs; // Return unchanged refs for other columns\n            }\n          }\n        });\n      }\n    });\n  };\n  const onDeleteCard = async cardId => {\n    await deleteCardMutation({\n      variables: {\n        cardId\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n        const newColumns = existingData.getColumns.map(column => {\n          const filteredCards = column.cards.filter(card => card.id !== cardId);\n          return {\n            ...column,\n            cards: filteredCards\n          };\n        });\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n  };\n  const onDragEnd = async result => {\n    const {\n      draggableId,\n      source,\n      destination\n    } = result;\n    if (!destination || destination.droppableId === source.droppableId && destination.index === source.index) {\n      return; // Do nothing if there's no destination or the card was dropped back to its original place\n    }\n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n        const newColumns = existingData.getColumns.map(column => ({\n          ...column,\n          cards: [...column.cards]\n        }));\n        const sourceColumnIndex = newColumns.findIndex(column => column.id === source.droppableId);\n        const cardIndex = newColumns[sourceColumnIndex].cards.findIndex(card => card.id === draggableId);\n        const [movedCard] = newColumns[sourceColumnIndex].cards.splice(cardIndex, 1);\n        const destinationColumnIndex = newColumns.findIndex(column => column.id === destination.droppableId);\n        newColumns[destinationColumnIndex].cards.splice(destination.index, 0, movedCard);\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n  };\n  const onUserSelect = async (cardId, user) => {\n    await changeUserMutation({\n      variables: {\n        cardId,\n        assignedUser: user.id\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n        const newColumns = existingData.getColumns.map(column => {\n          const newCards = column.cards.map(card => {\n            if (card.id === cardId) {\n              return {\n                ...card,\n                assignedUser: user.id\n              };\n            }\n            return card;\n          });\n          return {\n            ...column,\n            cards: newCards\n          };\n        });\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    }).catch(error => console.error('Failed to assign user to card:', error));\n  };\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns || []);\n      setUsers(data.getUsers || []);\n    }\n  });\n  return {\n    loading,\n    error,\n    columns,\n    draggedCard,\n    users,\n    setDraggedCard,\n    onAddCard,\n    onDragEnd,\n    onDeleteCard,\n    onUserSelect,\n    sortCardsInColumn\n  };\n};\n_s(useBoard, \"d/h7A5RB5l8QSMQ34A9Jk62o8c4=\", false, function () {\n  return [useQuery, useMutation, useMutation, useMutation, useMutation];\n});\nexport default useBoard;","map":{"version":3,"names":["useEffect","useState","useMutation","useQuery","GET_COLUMNS","ADD_CARD","MOVE_CARD","DELETE_CARD","CHANGE_USER","useBoard","_s","loading","error","data","columns","setColumns","addCardMutation","moveCardMutation","deleteCardMutation","changeUserMutation","draggedCard","setDraggedCard","users","setUsers","sortCardsInColumn","columnId","sortOrder","sortedColumns","map","column","id","sortedCards","cards","sort","a","b","Date","creationDate","getTime","customOrder","onAddCard","text","trim","optimisticCardId","Math","floor","random","variables","optimisticResponse","__typename","addCard","assignedUser","toISOString","update","cache","modify","fields","getColumns","existingColumnRefs","readField","newCardRef","writeFragment","fragment","gql","columnIdToUpdate","find","columnRef","identify","existingCardRefs","onDeleteCard","cardId","existingData","readQuery","query","newColumns","filteredCards","filter","card","writeQuery","onDragEnd","result","draggableId","source","destination","droppableId","index","newColumnId","moveCard","sourceColumnIndex","findIndex","cardIndex","movedCard","splice","destinationColumnIndex","onUserSelect","user","newCards","catch","console","getUsers"],"sources":["/Users/dazzlinger/Desktop/start_here/TaskFlow/client/src/main/components/Board/hook.ts"],"sourcesContent":["import { useEffect, useState } from 'react'\nimport { type DropResult } from 'react-beautiful-dnd'\nimport { useMutation, useQuery } from '@apollo/client'\n\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from 'graphql/queries'\n\nimport { type User, type BoardData, type Column } from 'main/types'\n\nexport interface UseBoardReturn {\n  loading: boolean\n  error: Error | undefined\n  columns: Column[] | undefined\n  draggedCard: string | null\n  users: User[]\n  setDraggedCard: (cardId: string | null) => void\n  onAddCard: (columnId: string, text: string) => Promise<void>\n  onDragEnd: (result: any) =>  Promise<void>\n  onDeleteCard: (cardId: string) => Promise<void>\n  onUserSelect: (cardId: string, user: User) => Promise<void>\n  sortCardsInColumn: (columnId: string, sortOrder: string) => void\n}\n\nconst useBoard = (): UseBoardReturn => {\n  const { loading, error, data } = useQuery<BoardData>(GET_COLUMNS)\n  const [columns, setColumns] = useState<Column[]>([])\n  const [addCardMutation] = useMutation(ADD_CARD)\n  const [moveCardMutation] = useMutation(MOVE_CARD)\n  const [deleteCardMutation] = useMutation(DELETE_CARD)\n  const [changeUserMutation] = useMutation(CHANGE_USER)\n  const [draggedCard, setDraggedCard] = useState<string | null>(null)\n  const [users, setUsers] = useState<User[]>([])\n\n  const sortCardsInColumn = (columnId: string, sortOrder: string) => {\n    const sortedColumns = columns.map(column => {\n      if (column.id === columnId) {\n        const sortedCards = [...column.cards]\n        if (sortOrder === 'creationDate') {\n          sortedCards.sort((a, b) => new Date(a.creationDate).getTime() - new Date(b.creationDate).getTime())\n        } else if (sortOrder === 'customOrder') {\n          sortedCards.sort((a, b) => a.customOrder - b.customOrder)\n        }\n        return { ...column, cards: sortedCards }\n      }\n      return column\n    })\n  \n    setColumns(sortedColumns)\n  }\n  \n  const onAddCard = async (columnId: string, text: string) => {\n    if (!text.trim()) return\n  \n    const optimisticCardId = 'temp-id' \n    const customOrder = Math.floor(Math.random() * 101)\n  \n    await addCardMutation({\n      variables: { columnId, text },\n      optimisticResponse: {\n        __typename: 'Mutation',\n        addCard: {\n          __typename: 'Card',\n          id: optimisticCardId,\n          text,\n          assignedUser: null,\n          creationDate: new Date().toISOString(),\n          customOrder\n        }\n      },\n      update(cache) {\n        cache.modify({\n          fields: {\n            getColumns(existingColumnRefs, { readField }) {\n              const newCardRef = cache.writeFragment({\n                data: addCard,\n                fragment: gql`\n                  fragment NewCard on Card {\n                    id\n                    text\n                    assignedUser\n                    creationDate\n                    customOrder\n                  }\n                `\n              })\n      \n              const columnIdToUpdate = columnId\n              const column = existingColumnRefs.find(\n                columnRef => readField('id', columnRef) === columnIdToUpdate\n              )\n      \n              if (column) {\n                cache.modify({\n                  id: cache.identify(column),\n                  fields: {\n                    cards(existingCardRefs = []) {\n                      return [...existingCardRefs, newCardRef]\n                    }\n                  }\n                })\n              }\n      \n              return existingColumnRefs // Return unchanged refs for other columns\n            }\n          }\n        })\n      }\n    })\n  }\n\n  const onDeleteCard = async (cardId: string) => {\n    await deleteCardMutation({\n      variables: { cardId },\n      update: (cache) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        const newColumns = existingData.getColumns.map(column => {\n          const filteredCards = column.cards.filter(card => card.id !== cardId)\n          return { ...column, cards: filteredCards }\n        })\n  \n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n  }\n\n  const onDragEnd = async (result: DropResult) => {\n    const { draggableId, source, destination } = result\n  \n    if (!destination || (destination.droppableId === source.droppableId && destination.index === source.index)) {\n      return // Do nothing if there's no destination or the card was dropped back to its original place\n    }\n  \n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: (cache) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        const newColumns = existingData.getColumns.map(column => ({ ...column, cards: [...column.cards] }))\n  \n        const sourceColumnIndex = newColumns.findIndex(column => column.id === source.droppableId)\n        const cardIndex = newColumns[sourceColumnIndex].cards.findIndex(card => card.id === draggableId)\n        const [movedCard] = newColumns[sourceColumnIndex].cards.splice(cardIndex, 1)\n  \n        const destinationColumnIndex = newColumns.findIndex(column => column.id === destination.droppableId)\n        newColumns[destinationColumnIndex].cards.splice(destination.index, 0, movedCard)\n  \n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n  }\n\n  const onUserSelect = async (cardId: string, user: User) => {\n    await changeUserMutation({\n      variables: { cardId, assignedUser: user.id },\n      update: (cache) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n\n        const newColumns = existingData.getColumns.map(column => {\n          const newCards = column.cards.map(card => {\n            if (card.id === cardId) {\n              return { ...card, assignedUser: user.id }\n            }\n            return card\n          })\n          return { ...column, cards: newCards }\n        })\n\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    }).catch(error => console.error('Failed to assign user to card:', error))\n  }\n\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns || [])\n      setUsers(data.getUsers || [])\n    }\n  })\n\n  return {\n    loading,\n    error,\n    columns,\n    draggedCard,\n    users,\n    setDraggedCard,\n    onAddCard,\n    onDragEnd,\n    onDeleteCard,\n    onUserSelect,\n    sortCardsInColumn\n  }\n}\n\nexport default useBoard\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}