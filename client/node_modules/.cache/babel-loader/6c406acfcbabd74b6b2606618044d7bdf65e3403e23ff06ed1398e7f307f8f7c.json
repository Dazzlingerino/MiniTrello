{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useState } from 'react';\nimport { useMutation, useQuery } from '@apollo/client';\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from '../graphql/queries';\nconst useTaskFlow = () => {\n  _s();\n  const {\n    loading,\n    error,\n    data\n  } = useQuery(GET_COLUMNS);\n  const [columns, setColumns] = useState([]);\n  const [addCardMutation] = useMutation(ADD_CARD);\n  const [moveCardMutation] = useMutation(MOVE_CARD);\n  const [deleteCardMutation] = useMutation(DELETE_CARD);\n  const [changeUserMutation] = useMutation(CHANGE_USER);\n  const [newCardText, setNewCardText] = useState('');\n  const [draggedCard, setDraggedCard] = useState(null);\n  const [users, setUsers] = useState([]);\n  const handleAddCard = async columnId => {\n    await addCardMutation({\n      variables: {\n        columnId,\n        text: newCardText\n      },\n      update: (cache, {\n        data: {\n          addCard\n        }\n      }) => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n        const newColumns = existingData.getColumns.map(column => {\n          if (column.id === columnId) {\n            return {\n              ...column,\n              cards: [...column.cards, addCard]\n            };\n          }\n          return column;\n        });\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: newColumns\n          }\n        });\n      }\n    });\n    setNewCardText('');\n  };\n  const handleDeleteCard = async cardId => {\n    await deleteCardMutation({\n      variables: {\n        cardId\n      }\n    });\n  };\n  const handleDragEnd = async result => {\n    const {\n      draggableId,\n      source,\n      destination\n    } = result;\n\n    // If there is no destination (dropped outside of any column) or if the item was dropped in the original place, do nothing\n    if (!destination || destination.droppableId === source.droppableId && destination.index === source.index) {\n      return;\n    }\n\n    // Perform the move operation in the backend\n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        __typename: 'Mutation',\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: cache => {\n        const existingData = cache.readQuery({\n          query: GET_COLUMNS\n        });\n        if (!existingData) return;\n\n        // Find the source and destination columns\n        const sourceColumn = existingData.getColumns.find(column => column.id === source.droppableId);\n        const destinationColumn = existingData.getColumns.find(column => column.id === destination.droppableId);\n\n        // Clone the columns to avoid directly mutating the cache\n        const newSourceColumn = {\n          ...sourceColumn,\n          cards: [...sourceColumn.cards]\n        };\n        const newDestinationColumn = {\n          ...destinationColumn,\n          cards: [...destinationColumn.cards]\n        };\n\n        // Find the card being moved\n        const cardIndex = newSourceColumn.cards.findIndex(card => card.id === draggableId);\n        const [movedCard] = newSourceColumn.cards.splice(cardIndex, 1);\n\n        // Insert the card into the new column at the correct position\n        newDestinationColumn.cards.splice(destination.index, 0, movedCard);\n\n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: existingData.getColumns.map(column => {\n              if (column.id === source.droppableId) return newSourceColumn;\n              if (column.id === destination.droppableId) return newDestinationColumn;\n              return column;\n            })\n          }\n        });\n      }\n    });\n  };\n  const assignUserToCard = async (cardId, userId) => {\n    await changeUserMutation({\n      variables: {\n        cardId,\n        assignedUser: userId\n      }\n      // Cache update logic here\n    });\n  };\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns);\n      setUsers(data.getUsers);\n    }\n  }, [loading, data]);\n  return {\n    loading,\n    error,\n    columns,\n    newCardText,\n    draggedCard,\n    users,\n    setNewCardText,\n    setDraggedCard,\n    handleAddCard,\n    handleDragEnd,\n    handleDeleteCard,\n    assignUserToCard\n  };\n};\n_s(useTaskFlow, \"LffhRVbkpX8S4toBrUv6twPdZhk=\", false, function () {\n  return [useQuery, useMutation, useMutation, useMutation, useMutation];\n});\nexport default useTaskFlow;","map":{"version":3,"names":["useEffect","useState","useMutation","useQuery","GET_COLUMNS","ADD_CARD","MOVE_CARD","DELETE_CARD","CHANGE_USER","useTaskFlow","_s","loading","error","data","columns","setColumns","addCardMutation","moveCardMutation","deleteCardMutation","changeUserMutation","newCardText","setNewCardText","draggedCard","setDraggedCard","users","setUsers","handleAddCard","columnId","variables","text","update","cache","addCard","existingData","readQuery","query","newColumns","getColumns","map","column","id","cards","writeQuery","handleDeleteCard","cardId","handleDragEnd","result","draggableId","source","destination","droppableId","index","newColumnId","optimisticResponse","__typename","moveCard","sourceColumn","find","destinationColumn","newSourceColumn","newDestinationColumn","cardIndex","findIndex","card","movedCard","splice","assignUserToCard","userId","assignedUser","getUsers"],"sources":["/Users/dazzlinger/Desktop/start_here/TaskFlow/client/src/main/hook.ts"],"sourcesContent":["import { useEffect, useState } from 'react'\nimport { DropResult } from 'react-beautiful-dnd'\nimport { useMutation, useQuery } from '@apollo/client'\nimport { GET_COLUMNS, ADD_CARD, MOVE_CARD, DELETE_CARD, CHANGE_USER } from '../graphql/queries'\nimport { type User, type BoardData, type Column, type Card } from './types'\n\nexport interface UseTaskFlowReturn {\n  loading: boolean;\n  error: Error | undefined;\n  columns: Column[] | undefined;\n  newCardText: string;\n  draggedCard: string | null;\n  users: User[];\n  setNewCardText: (text: string) => void;\n  setDraggedCard: (cardId: string | null) => void;\n  handleAddCard: (columnId: string) => Promise<void>;\n  handleDragEnd: (result: any) =>  Promise<void>;\n  handleDeleteCard: (cardId: string) => Promise<void>;\n  assignUserToCard: (cardId: string, userId: string) => Promise<void>;\n}\n\nconst useTaskFlow = (): UseTaskFlowReturn => {\n  const { loading, error, data } = useQuery<BoardData>(GET_COLUMNS)\n  const [columns, setColumns] = useState<Column[]>([])\n  const [addCardMutation] = useMutation(ADD_CARD)\n  const [moveCardMutation] = useMutation(MOVE_CARD)\n  const [deleteCardMutation] = useMutation(DELETE_CARD)\n  const [changeUserMutation] = useMutation(CHANGE_USER)\n  const [newCardText, setNewCardText] = useState('')\n  const [draggedCard, setDraggedCard] = useState<string | null>(null)\n  const [users, setUsers] = useState<User[]>([])\n\n  const handleAddCard = async (columnId: string) => {\n    await addCardMutation({\n      variables: { columnId, text: newCardText },\n      update: (cache, { data: { addCard } }) => {\n        const existingData = cache.readQuery<{ getColumns: Column[] }>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        const newColumns = existingData.getColumns.map((column: Column) => {\n          if (column.id === columnId) {\n            return { ...column, cards: [...column.cards, addCard] }\n          }\n          return column\n        })\n  \n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: { getColumns: newColumns }\n        })\n      }\n    })\n    setNewCardText('')\n  }\n\n  const handleDeleteCard = async (cardId: string) => {\n    await deleteCardMutation({\n      variables: { cardId }\n    })\n  }\n\n  const handleDragEnd = async (result) => {\n    const { draggableId, source, destination } = result\n  \n    // If there is no destination (dropped outside of any column) or if the item was dropped in the original place, do nothing\n    if (!destination || (destination.droppableId === source.droppableId && destination.index === source.index)) {\n      return\n    }\n  \n    // Perform the move operation in the backend\n    await moveCardMutation({\n      variables: {\n        cardId: draggableId,\n        newColumnId: destination.droppableId\n      },\n      optimisticResponse: {\n        __typename: 'Mutation',\n        moveCard: {\n          __typename: 'Card',\n          id: draggableId,\n          columnId: destination.droppableId\n        }\n      },\n      update: (cache) => {\n        const existingData = cache.readQuery<BoardData>({ query: GET_COLUMNS })\n        if (!existingData) return\n  \n        // Find the source and destination columns\n        const sourceColumn = existingData.getColumns.find(column => column.id === source.droppableId)\n        const destinationColumn = existingData.getColumns.find(column => column.id === destination.droppableId)\n  \n        // Clone the columns to avoid directly mutating the cache\n        const newSourceColumn = { ...sourceColumn, cards: [...sourceColumn.cards] }\n        const newDestinationColumn = { ...destinationColumn, cards: [...destinationColumn.cards] }\n  \n        // Find the card being moved\n        const cardIndex = newSourceColumn.cards.findIndex(card => card.id === draggableId)\n        const [movedCard] = newSourceColumn.cards.splice(cardIndex, 1)\n  \n        // Insert the card into the new column at the correct position\n        newDestinationColumn.cards.splice(destination.index, 0, movedCard)\n  \n        // Write the updated columns back to the cache\n        cache.writeQuery({\n          query: GET_COLUMNS,\n          data: {\n            getColumns: existingData.getColumns.map(column => {\n              if (column.id === source.droppableId) return newSourceColumn\n              if (column.id === destination.droppableId) return newDestinationColumn\n              return column\n            })\n          }\n        })\n      }\n    })\n  }\n  \n  const assignUserToCard = async (cardId: string, userId: string) => {\n    await changeUserMutation({\n      variables: { cardId, assignedUser: userId }\n      // Cache update logic here\n    })\n  }\n\n  useEffect(() => {\n    if (!loading && data) {\n      setColumns(data.getColumns)\n      setUsers(data.getUsers)\n    }\n  }, [loading, data])\n\n  return {\n    loading,\n    error,\n    columns,\n    newCardText,\n    draggedCard,\n    users,\n    setNewCardText,\n    setDraggedCard,\n    handleAddCard,\n    handleDragEnd,\n    handleDeleteCard,\n    assignUserToCard\n  }\n}\n\nexport default useTaskFlow\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}